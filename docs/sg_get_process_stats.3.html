<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>sg_get_process_stats</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="sg_get_process_stats"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>sg_get_process_stats, sg_get_process_stats_r, sg_get_process_count, sg_get_process_count_of, sg_get_process_count_r, sg_free_process_count, sg_process_compare_name, sg_process_compare_pid, sg_process_compare_uid, sg_process_compare_gid, sg_process_compare_size, sg_process_compare_res, sg_process_compare_cpu, sg_process_compare_time &#8212; get process statistics</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;statgrab.h&gt;</pre><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">sg_process_stats *<b class="fsfunc">sg_get_process_stats</b>(</code></td><td><var class="pdparam">entries</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>size_t *<var class="pdparam">entries</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">sg_process_stats *<b class="fsfunc">sg_get_process_stats_r</b>(</code></td><td><var class="pdparam">entries</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>size_t *<var class="pdparam">entries</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">sg_error <b class="fsfunc">sg_free_process_stats</b>(</code></td><td><var class="pdparam">data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>sg_process_stats *<var class="pdparam">data</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">sg_process_count *<b class="fsfunc">sg_get_process_count</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">sg_process_count *<b class="fsfunc">sg_get_process_count_of</b>(</code></td><td><var class="pdparam">pcs</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>sg_process_count_source <var class="pdparam">pcs</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">sg_process_count *<b class="fsfunc">sg_get_process_count_r</b>(</code></td><td><var class="pdparam">whereof</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>sg_process_stats const *<var class="pdparam">whereof</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">sg_error <b class="fsfunc">sg_free_process_count</b>(</code></td><td><var class="pdparam">data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>sg_process_count *<var class="pdparam">data</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">sg_process_compare_name</b>(</code></td><td><var class="pdparam">va</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>const void *<var class="pdparam">va</var></code>;<br><code>const void *<var class="pdparam">vb</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">sg_process_compare_pid</b>(</code></td><td><var class="pdparam">va</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>const void *<var class="pdparam">va</var></code>;<br><code>const void *<var class="pdparam">vb</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">sg_process_compare_uid</b>(</code></td><td><var class="pdparam">va</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>const void *<var class="pdparam">va</var></code>;<br><code>const void *<var class="pdparam">vb</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">sg_process_compare_gid</b>(</code></td><td><var class="pdparam">va</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>const void *<var class="pdparam">va</var></code>;<br><code>const void *<var class="pdparam">vb</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">sg_process_compare_size</b>(</code></td><td><var class="pdparam">va</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>const void *<var class="pdparam">va</var></code>;<br><code>const void *<var class="pdparam">vb</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">sg_process_compare_res</b>(</code></td><td><var class="pdparam">va</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>const void *<var class="pdparam">va</var></code>;<br><code>const void *<var class="pdparam">vb</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">sg_process_compare_cpu</b>(</code></td><td><var class="pdparam">va</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>const void *<var class="pdparam">va</var></code>;<br><code>const void *<var class="pdparam">vb</var></code>;</div><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">sg_process_compare_time</b>(</code></td><td><var class="pdparam">va</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">vb</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>const void *<var class="pdparam">va</var></code>;<br><code>const void *<var class="pdparam">vb</var></code>;</div><div class="funcprototype-spacer"> </div></div></div><div class="refsect1"><a name="idm115"></a><h2>Description</h2><p>
      The <code class="function">sg_get_process_stats</code> functions provide
      statistics about the currently running processes. Both functions,
      <code class="function">sg_get_process_stats</code>() and
      <code class="function">sg_get_process_stats_r</code>(), take an optional
      <em class="parameter"><code>entries</code></em> parameter, which points
      (when given) to a size_t to take the number of returned vector
      entries.
    </p><p>
      The functions <code class="function">sg_get_process_count_of</code>() and
      <code class="function">sg_get_process_count_r</code>() provide an aggregated
      view of the process table - they deliver the amount of processes
      per process state. The <code class="function">sg_get_process_count</code>()
      is in fact a preprocessor macro for backward compatibility and calls
      <code class="function">sg_get_process_count_of</code>() with the parameter
      <em class="parameter"><code>pcs</code></em> of sg_entire_process_count to emulate
      the behavior until 0.17.
    </p><p>
      </p><div class="table"><a name="idm129"></a><p class="title"><b>Table 1. API Shortcut</b></p><div class="table-contents"><table class="table" summary="API Shortcut" border="1"><colgroup><col align="left" class="function"><col align="left" class="returns"><col align="left" class="data owner"></colgroup><thead><tr><th align="left">function</th><th align="left">returns</th><th align="left">data owner</th></tr></thead><tbody><tr><td align="left">sg_get_process_stats</td><td align="left"><span class="structname">sg_process_stats</span> *</td><td align="left">libstatgrab (thread local)</td></tr><tr><td align="left">sg_get_process_stats_r</td><td align="left"><span class="structname">sg_process_stats</span> *</td><td align="left">caller</td></tr><tr><td align="left">sg_get_process_count_of</td><td align="left"><span class="structname">sg_process_count</span> *</td><td align="left">libstatgrab (thread local)</td></tr><tr><td align="left">sg_get_process_count_r</td><td align="left"><span class="structname">sg_process_count</span> *</td><td align="left">caller</td></tr></tbody></table></div></div><p><br class="table-break">
    </p><p>
      The <span class="structname">sg_process_stats</span> vectors received from
      <code class="function">sg_get_process_stats_r</code>() or the
      <span class="structname">sg_process_count</span> summaries received from
      <code class="function">sg_get_process_count_r</code> must be
      freed using <code class="function">sg_free_process_stats</code>() or
      <code class="function">sg_free_process_count</code>(), respectively.
      The caller is responsible for doing it when the data isn't needed
      any more.
    </p><p>
      </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="function">sg_process_compare_name</code></td></tr><tr><td><code class="function">sg_process_compare_pid</code></td></tr><tr><td><code class="function">sg_process_compare_uid</code></td></tr><tr><td><code class="function">sg_process_compare_gid</code></td></tr><tr><td><code class="function">sg_process_compare_size</code></td></tr><tr><td><code class="function">sg_process_compare_res</code></td></tr><tr><td><code class="function">sg_process_compare_cpu</code></td></tr><tr><td><code class="function">sg_process_compare_time</code></td></tr></table><p>
    </p><p>
      These functions compare two sg_process_stats entries, and return an
      int to represent which one is greater. The main use of these functions
      is to be passed to qsort to sort the sg_process_stats by the given type.
      </p><div class="example"><a name="idm187"></a><p class="title"><b>Example 1. Example</b></p><div class="example-contents"><pre class="programlisting">
size_t entries;
sg_process_stats *proc_stats = NULL;
while( NULL != ( proc_stats = sg_get_process_stats_r(&amp;entries) ) ) {
    /* order entries by comparing the process identifier */
    qsort( proc_stats, entries, sizeof(proc_stats[0]), &amp;sg_process_compare_pid );
    show_proc_stats( proc_stats );
    sg_free_process_stats( proc_stats );
}
        </pre></div></div><p><br class="example-break">
    </p></div><div class="refsect1"><a name="idm190"></a><h2>Return Values</h2><p>
      The structure returned by sg_get_process_stats is of type
      <span class="structname">sg_process_stats</span>.
    </p><pre class="programlisting">
typedef struct {
        char *process_name;
        char *proctitle;

        pid_t pid;    /* process identifier */
        pid_t parent; /* Parent pid */
        pid_t pgid;   /* process id of process group leader */
        pid_t sessid; /* session id of the session the process belongs to */

        uid_t uid;
        uid_t euid;
        gid_t gid;
        gid_t egid;

        unsigned long long context_switches;
        unsigned long long voluntary_context_switches;
        unsigned long long involuntary_context_switches;
        unsigned long long proc_size; /* in bytes */
        unsigned long long proc_resident; /* in bytes */
        time_t start_time; /* When was the process started */
        time_t time_spent; /* time running in seconds */
        double cpu_percent;
        int nice;
        sg_process_state state;

        time_t systime;
} sg_process_stats;
    </pre><pre class="programlisting">
typedef enum {
        SG_PROCESS_STATE_RUNNING,
        SG_PROCESS_STATE_SLEEPING,
        SG_PROCESS_STATE_STOPPED,
        SG_PROCESS_STATE_ZOMBIE,
        SG_PROCESS_STATE_UNKNOWN
} sg_process_state;
    </pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="structfield"><code>process_name</code></em></span></dt><dd><p>
            The name of the command that was run. The content of this
            field heavily depends on the underlying operating system,
            some store the basename the executable passes to
            the <code class="function">exec</code>(2) system call, some the entire
            path. Most OS restrict the size of this field - some like
            the *BSD family to a very low value of 15 bytes.
          </p><p>
            This field is usually immutable for userland processes.
          </p></dd><dt><span class="term"><em class="structfield"><code>proctitle</code></em></span></dt><dd><p>
            The command line (the "title") of the process. Take
            note - this can be modified by the process, so isn't
            guaranteed to be the original command line.
          </p></dd><dt><span class="term"><em class="structfield"><code>pid</code></em></span></dt><dd><p>
            The process ID.
          </p></dd><dt><span class="term"><em class="structfield"><code>parent</code></em></span></dt><dd><p>
            The parent process ID.
          </p></dd><dt><span class="term"><em class="structfield"><code>pgid</code></em></span></dt><dd><p>
            The process ID of the process group leader.
          </p></dd><dt><span class="term"><em class="structfield"><code>sessid</code></em></span></dt><dd><p>
            Session id of the session the process belongs to.
          </p></dd><dt><span class="term"><em class="structfield"><code>uid</code></em></span></dt><dd><p>
            The ID of the user the process is running as.
          </p></dd><dt><span class="term"><em class="structfield"><code>euid</code></em></span></dt><dd><p>
            The ID of the effective user the process is running as.
          </p></dd><dt><span class="term"><em class="structfield"><code>gid</code></em></span></dt><dd><p>
            The ID of the group the process is running as.
          </p></dd><dt><span class="term"><em class="structfield"><code>egid</code></em></span></dt><dd><p>
            The ID of the effective group the process is running as.
          </p></dd><dt><span class="term"><em class="structfield"><code>context_switches</code></em></span></dt><dd><p>
            The number of context switches of this process (voluntary and involuntary).
          </p></dd><dt><span class="term"><em class="structfield"><code>voluntary_context_switches</code></em></span></dt><dd><p>
            The number of voluntary context switches of this process (eg.
            by calling <code class="function">sched_yield</code>() or <code class="function">sleep</code>()).
          </p></dd><dt><span class="term"><em class="structfield"><code>involuntary_context_switches</code></em></span></dt><dd><p>
            The number of involuntary context switches of this process (eg.
            time slice exhausted or signal sent).
          </p></dd><dt><span class="term"><em class="structfield"><code>proc_size</code></em></span></dt><dd><p>
            The virtual memory size of the process in bytes.
          </p></dd><dt><span class="term"><em class="structfield"><code>proc_resident</code></em></span></dt><dd><p>
            The size of the process that's resident in memory.
          </p></dd><dt><span class="term"><em class="structfield"><code>start_time</code></em></span></dt><dd><p>
            The time when the process has been started in seconds since
            epoch.
          </p></dd><dt><span class="term"><em class="structfield"><code>time_spent</code></em></span></dt><dd><p>
            The number of seconds the process has been running (user+system
            time, without time spent by child processes).
          </p></dd><dt><span class="term"><em class="structfield"><code>cpu_percent</code></em></span></dt><dd><p>
            The current percentage of CPU the process is using.
          </p></dd><dt><span class="term"><em class="structfield"><code>nice</code></em></span></dt><dd><p>
            The nice value of the process.
          </p></dd><dt><span class="term"><em class="structfield"><code>state</code></em></span></dt><dd><p>
            The current state of the process. See sg_process_state
            for permitted values.
          </p></dd><dt><span class="term"><em class="structfield"><code>systime</code></em></span></dt><dd><p>
            The time in seconds since epoch of the moment where the present
            statistic has been created. This might be (but doesn't have to
            be) the same moment for all returned entries, regardless whether
            they're fetched with one snapshot or puzzled from some kind of
            procfs.
          </p></dd></dl></div><p>
      The structure returned by sg_get_process_count_of and
      sg_get_process_count_r is of type
      <span class="structname">sg_process_count</span>.
    </p><pre class="programlisting">
typedef enum sg_process_count_source {
        sg_entire_process_count,
        sg_last_process_count
} sg_process_count_source;
    </pre><pre class="programlisting">
typedef struct{
        unsigned long long total;
        unsigned long long running;
        unsigned long long sleeping;
        unsigned long long stopped;
        unsigned long long zombie;
        unsigned long long unknown;

        time_t systime;
}sg_process_count;
    </pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="structfield"><code>total</code></em></span></dt><dd><p>
            The total number of processes.
          </p></dd><dt><span class="term"><em class="structfield"><code>running</code></em></span></dt><dd><p>
            The number of running processes.
          </p></dd><dt><span class="term"><em class="structfield"><code>sleeping</code></em></span></dt><dd><p>
            The number of sleeping processes.
          </p></dd><dt><span class="term"><em class="structfield"><code>stopped</code></em></span></dt><dd><p>
            The number of stopped processes.
          </p></dd><dt><span class="term"><em class="structfield"><code>zombie</code></em></span></dt><dd><p>
            The number of zombie processes.
          </p></dd><dt><span class="term"><em class="structfield"><code>unknown</code></em></span></dt><dd><p>
            The number of processes not matching any of above named categories.
          </p></dd><dt><span class="term"><em class="structfield"><code>systime</code></em></span></dt><dd><p>
            The time in seconds since epoch of the moment where the present
            statistic has been created.
          </p></dd></dl></div></div><div class="refsect1"><a name="idm346"></a><h2>Bugs</h2><p>
      The very first call of
      <code class="function">sg_get_process_count_of</code>(sg_last_process_count)
      will return the same as
      <code class="function">sg_get_process_count_of</code>(sg_entire_process_count).
    </p><p>
      The compare functions exist rather for backward compatibility than
      for functionality enhancements. Limited flexibility (e.g. reverse
      order) and lack of optimising opportunities for the compiler leads
      to the recommendation to implement the required compare routines
      locally.
    </p></div><div class="refsect1"><a name="idm352"></a><h2>See Also</h2><span class="simplelist">
        <span class="citerefentry"><span class="refentrytitle">statgrab</span>(3)</span>
      </span></div><div class="refsect1"><a name="idm359"></a><h2>Website</h2><table border="0" summary="Simple list" class="simplelist"><tr><td>
        <a class="ulink" href="https://libstatgrab.org/" target="_top">
          https://libstatgrab.org/
        </a>
      </td></tr></table></div></div></body></html>
